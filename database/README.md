# Кеша и База данных

## Легенда

Недавно подруга Кеши - ворона Клара - нашла на помойке выброшенный компьютер. Попугай забрал находку
себе - он решил доказать Вовке, что умеет хорошо обращаться с дорогой техникой. Для этого Кеша решил
написать собственную нереляционную базу данных для хранения пар "ключ-значение".

## Техническое задание

### Что делать?

Вам необходимо реализовать методы класса `StorageAdapter`, чтобы, в конечном счете, Вы получили
простенькую базу данных, которая хранит данные на жестком диске Вашего устройства. Ниже будут
описаны алгоритмы, которыми Вы должны воспользоваться.

### Где хранить данные?

Для своей базы данных попугай выделил отдельную директорию на компьютере. Будем называть ее
*директорией-хранилищем*. База данных может проводить любые операции над *директорией-хранилищем*,
включая запись, чтение, удаление и так далее.

Нашли странный файл? Не беда - просто удалите. Кто-то изменил содержимое файла? Не беда - снова
можно удалить. Кто-то создал директорию? Угадаете? Да, можно удалить. В общем, директория полностью
выделена для Вас и только Вас.

### Как выполнять операции?

Сама по себе база данных будет транзакционной. Это значит, что она где-то копит операции, но не
выполняет их до тех пор, пока операции не будут подтверждены или отклонены. Изучите, пожалуйста,
тесты, чтобы лучше понять, как это выглядит и как это должно работать. В частности, Вам понадобятся
методы `commit` и `rollback`.

### Устойчивость к изменениям

К сожалению, на найденном компьютере обнаружились вирусы. Они могут в любой момент менять названия
файлов или их содержимое, что-нибудь удалять или, наоборот, создавать. *Директория-хранилище* не
является исключением. Кстати, рекомендуем держать в голове, что сама *директория-хранилище* тоже
может быть внезапно удалена.

### Какой алгоритм?

Чтобы гарантировать защищенность хранилища от внешнего воздействия, мы должны придумать какой-то
алгоритм хранения данных, который гарантирует возможность инвалидации в случае внешнего доступа.
Кроме того, мы бы хотели обезопасить хранилище таким образом, что никто извне не смог узнать, к
какому ключу относится некоторое значение.

Будем добиваться такого поведения следующим алгоритмом:

1. Используя [`hashlib.sha256`](https://docs.python.org/3/library/hashlib.html#usage), хэшируем
   ключ. Полученный хэш - название файла. Посмотрите на пример из документации - используем методы
   `hashlib.sha256.update` и `hashlib.sha256.hexdigest`.

2. Создаем файл и записываем в него `JSON` следующего формата (воспользуйтесь стандартным модулем
   [`json`](https://docs.python.org/3/library/json.html)):

    ```json
    {
        "hash": "...",
        "value": "..."
    }
    ```

    В атрибут `hash` записываем хеш от последовательного вызова `hashlib.sha256.update` для ключа и
    для значения.

    В атрибут `value` записываем значение по ключу.

Если кто-то изменит наши данные извне, то мы либо получим ошибку при валидации `JSON`, либо получим
разные хеши при чтении. Такого алгоритма нам будет достаточно.

Если кто-то изменил данные, то будем считать, что ключа никогда не существовало. То есть если мы
записали что-то в базу, а потом файл, в котором хранились данные, испортился, то можно ничего не
возвращать пользователю. Увы, но значение потеряно.

### Тестирование

В этой задаче приватных тестов нет. Внимательно ознакомьтесь с открытыми тестами, чтобы понимать,
как должна работать Ваша база данных. Мы старались делать их максимально простыми и понятными.
