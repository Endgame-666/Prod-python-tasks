# Кеша и CPython

## Легенда

Попугай Кеша каким-то образом попал на стажировку в IT-команду *"Союзмультфильма"*. Не теряя ни
минуты, он заявил, что когда в последний раз отдыхал на Таити, выучил `C++` и `Python`. Однако
попугай не учел, что ему могут выдать задание.

Руководитель команды Вовка давно хотел совместить `Python` и `C++`, используя `CPython` API. На
всякий случай, напомним пернатому другу, что каноническая реализация `Python` - это `CPython`. Как
понятно из названия, `Python` написан на `C`.

В команде используют систему сборки `Bazel`. Она очень требовательна к объявлению зависимостей. Все
файлы должны быть предоставлены заранее, равно как и остальные параметры и настройки. И все бы
ничего, но команда Вовки так и не определилась с версией `Python`, которую она будет использовать.
Если учитывать минорные версии, то между `3.8.0` и `3.12.4` вышло *69* версий! Никто не будет писать
конфигурации под 69 возможных случаев. Это мы еще не учли поиск самих файлов! Тем не менее,
компилировать проект как-то надо.

Кеша, как обычно, свою задачу повесил на Вас! Внимательно прочитайте техническое задание и помогите
Кеше дожить до первой зарплаты.

## Техническое задание

### Краткое описание

Вам необходимо реализовать программу, которая выполнит следующую последовательность действий:

1. Проверит текущую систему в соответствии с ограничениями, описанными ниже;
2. Удалит устаревшие файлы;
3. Найдет файлы `Python`, которые необходимы для сборки проекта, по алгоритму ниже;
4. Скопирует найденные файлы в директорию, выделенную для сборки проекта;
5. Запишет конфигурационный файл для `Bazel`, опираясь на скопированные файлы.

### Ограничения

Вовка сразу напомнил забывчивому попугаю ограничения, предъявляемые командой:

1. Никакая реализация, кроме `CPython`, нас не интересует. Действительно, как можно пользоваться
   `CPython` API, если нет самого `CPython`!

2. Хотим видеть версию `Python` не младше `3.8.0`, так как именно с этой версии появляется нужная
   Вовке фича.

3. Команда гарантирует стабильность своих приложений только на `Linux`, `Windows` и `macOS`, поэтому
   программу разрешено запускать только на них. Никакие `JavaOS` предусматривать не нужно.

Если какое-либо из условий нарушено, то Кеша должен вызвать исключение `AssertionError` с понятным
для пользователя сообщением.

### Система сборки

Для сборки на `Bazel` будет использовано правило `cc_import`. Его применяют для импортирования
заранее скомпилированных библиотек для `C` или `C++`. Давайте покажем пример, чтобы было более
понятно, что от Вас потребуется дальше.

```python
cc_import(
    ...,
    hdrs = [
        "dir/bar.hpp",
        "dir/baz.hpp",
    ],
    includes = ["dir"],
    interface_library = "mylib.lib",
    shared_library = "mylib.dll",
    ...,
)
```

Мы объявили *цель* со следующими атрибутами:

* `hdrs` - заголовочные файлы, доступные для использования в директиве `#include`;
* `includes` - список директорий, которые добавляются в поисковый путь компилятора;
* `interface_library` - библиотека-интерфейс, используемая при линковке разделяемой библиотеки;
* `shared_library` - предварительно скомпилированная разделяемая библиотека.

### Поиск файлов

#### Корень `CPython`

Корнем `CPython` считайте директорию для данных. Изучите документацию к `sysconfig`, чтобы узнать,
как получить путь до этой директории.

#### Заголовочные файлы (`hdrs`)

К заголовочным файлам отнесем все файлы с расширением `.h`, которые находятся в директории для
неплатформозависимых заголовочных файлов. Изучите документацию к `sysconfig`, чтобы узнать, как
получить путь до этой директории.

#### Включаемые директории (`includes`)

Необходимо собрать список всех директорий, содержащих заголовочные файлы из пункта выше. Кроме того,
эти директории должны быть префиксом для каждого файла. Ниже приведем пример.

Если вы нашли следующие заголовочные файлы:

* `one/two/file.hpp`;
* `one/two/three/four/file.hpp`;
* `one/two/three/five/file.hpp`;
* `one/two/six/file.hpp`;

То в качестве `includes` Вы запишете:

* `one/`;
* `one/two/`.

Потому что они являются префиксом для *каждого* файла из пункта выше.

#### Разделяемая библиотека (`shared_library`)

Сначала определим, где будем искать:

* На `Windows` используем корень `CPython`;
* На `macOS` и `Linux` используем конфигурационную переменную `LIBDIR`.

Далее, предполагая, что версия `Python` - это `{major}.{minor}.{patch}`, необходимо найти файл, имя
которого удовлетворяет платформозависимому паттерну:

* На `Windows` ищем `python{major}{minor}.dll`;
* На `macOS` ищем `libpython{major}.{minor}.dylib`;
* На `Linux` ищем `libpython{major}{minor}.so`.

Гарантируется, что файл ровно один и он существует. Файл может быть вложен в какие-то директории
относительно директории поиска.

#### Библиотека-интерфейс (`interface_library`)

Библиотека-интерфейс нужна только для `Windows`. Для остальных платформ атрибут `interface_library`
не требуется. В директории `libs/` относительно корня `CPython` требуется найти файл, имя которого
удовлетворяет паттерну `python{major}{minor}.lib`.

Гарантируется, что файл ровно один и он существует. Файл может быть вложен в какие-то директории
относительно директории поиска.

### Копирование

Допустим, что мы нашли некоторый нужный файл в некоторой директории поиска. Его будет необходимо
скопировать в директорию `third_party/cpython/internal/`, сохранив путь относительно директории
поиска. Удалять оригинальные файлы после копирования не нужно.

Например, мы искали заголовочные файлы (`hdrs`) в директории `/home/dev/` и нашли файл, который
имеет путь `/home/dev/abc/example.hpp`. После копирования относительно текущей директории он будет
перенес как `third_party/cpython/internal/abc/example.hpp`.

### Очистка мусора

Нужно предусмотреть, что в `third_party/cpython/` может быть мусор от предыдущих запусков скрипта.
Вам необходимо предусмотреть удаление `third_party/cpython/` вместе с ее содержимым при повторном
запуске программы.

### Конфигурационный файл

После того, как Вы нашли все пути и скопировали файлы в директорию сборки, Вам останется только
создать конфигурационный файл для `Bazel`.

В файл `third_party/cpython/BUILD.bazel` Вы должны записать следующее содержимое:

```python
cc_import(
    name = "cpython",
    hdrs = [
        "...",
        "...",
        "...",
    ],
    includes = [
        "...",
        "...",
        "...",
    ],
    interface_library = "...",
    shared_library = "...",
    visibility = ["//visibility:public"],
)
```

Вместо многоточий будут записаны пути до файлов относительно `third_party/cpython/`. Например, Вы
скопировали некоторый заголовочный файл, и он находится в `third_party/cpython/internal/file.hpp`.
Тогда он будет записан в `hdrs` как `internal/file.hpp`.
